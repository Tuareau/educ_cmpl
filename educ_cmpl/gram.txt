	* program *
	S() {
		get_token() != “PROGRAMM” -> error()
		get_token() != ”;” -> error()
		PROGRAM_BODY();	
		get_token() != “END” 
		get_token() != “.”
	}

	* program body *
	PROGRAM_BODY() {
		while (ok)
			try LANG_CONSTRUCT()
	}

	LANG_CONSTRUCT() {
		try VAR_DECL();
		else try FUNC_DEF();
		else try ARYTHM_EXPR(); get_token() != “;” 
		else try FUNC_CALL(); get_token() “;” 
		else try LANG_OPERATOR();
	}

	* variable or function parameter declaration *
	VAR_DECL() {
		try TYPE(); try IDENT(); get_token() != ”;”
	}

	TYPE() {
		get_token() != “integer” | “string” | “bool”;
	}

	* identificator *
	IDENT() { 
		get_token().type != Type::IDENT;
	}

	* function definition *
	FUNC_DEF() {
		try FUNC_DECL(); try FUNC_BODY(); 
		get_token() != “ENDF”; 
		get_token() != “;”
	}

	FUNC_DECL() {
		get_token() != “FUNC”;
		try IDENT();
		”(“ // дальше пример проверки на символ опускается 
		while (ok)
			try FUNC_PARAM(); ","
		”)” “;”
	}

	FUNC_PARAM() {
		try TYPE(); try IDENT();
	}

	* function body *
	FUNC_BODY() {
		while (ok)
			try FUNC_CONSTRUCT();
	}
	
	FUNC_CONSTRUCT() {
		try VAR_DECL();
		else try ARYTHM_EXPR();
		else try FUNC_CALL(); ”;”  
		else try LANG_OPERATOR();
		else try RETURN_OP();
	}

	* function constructions *
	RETURN_OP() {
		“return” 
		try RETURN_EXPR();
		”;”
	}

	RETURN_EXPR() {
		try FUNC_CALL();
		else try ARYTHM_EXPR();
		else try LOGICAL_EXPR();
		else try IDENT();
	}

	* function call *
	FUNC_CALL() {
		try IDENT(); 
		”(“ 
		while (ok)
			try ARG(); 
		”)”
	}

	ARG() {
		try IDENT();
		else try CONST_EXPR();
	}

	* arythmetic expression *
	ARYTHM_EXPR() {
		try IDENT(); “=” try IDENT(); 
		else try IDENT(); “=” try ARITHM_OPERATION(); 
		else try IDENT(); “=” try LOGICAL_EXPR(); 
		else try IDENT(); “=” try CONST_EXPR(); 
	}

	* arythmetic operation *
	ARITHM_OPERATION() {
		try OPERAND() try OP() try OPERAND()
		else try OPERAND()  try OP() try ARITHM_OPERATION() 
	}

	OP() {
		try “+” | “-“ | “/” | “*”
	}

	OPERAND() {
		try IDENT();
		else try CONST_EXPR();
		else try FUNC_CALL();
	}

	* constant expression *
	CONST_EXPR() {
		is_constant();
	}

	* logical expression *
	LOGICAL_EXPR() {
		try LOGICAL_OPERATION();
		else try LOGICAL_STATEMENT();
		else try “(” LOGICAL_OPERATION(); “)”
	}

	LOGICAL_OPERATION() {
		try OPERAND(); try LOGICAL_OP(); try OPERAND();
	}

	LOGICAL_OP() {
		“>” | “<” | “==”
	}

	LOGICAL_STATEMENT() {
		try IDENT();
		else try is_constant();
		else try FUNC_CALL(); 
	}

	* language operators *
	LANG_OPERATOR() {
		try WHILE_OP();
		else try IF_OP();
		else try WRITE_OP();
	}

	WRITE_OP() {
		try “write” “(“ while (ok) try ARG(); try "," “)” “;”
	}

	WHILE_OP() { 
		try “WHILE” LOGICAL_EXPR() “DO” while (ok) { try OPERATION(); } “ENDWHILE” “;”
	}

	<IF_OP> {
		try “if” LOGICAL_EXPR() “then” while (ok) { try OPERATION(); } “endif” ”;”
		else try “if” LOGICAL_EXPR() “then” while (ok) { try OPERATION(); } “else” while (ok) { try OPERATION(); } “endif” “;”
	}

	OPERATION() {
		try “EXITWHILE” “;”
		else try LANG_OPERATOR();
		else try FUNC_CALL(); “;”
		else try ARYTHM_EXPR(); “;”
		else try VAR_DECL();
	}